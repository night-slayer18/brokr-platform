scalar Map
scalar Long

enum Role {
    VIEWER
    ADMIN
    SUPER_ADMIN
    SERVER_ADMIN
}

enum EnvironmentType {
    NON_PROD_HOTFIX
    NON_PROD_MINOR
    NON_PROD_MAJOR
    PROD
}

enum SecurityProtocol {
    PLAINTEXT
    SSL
    SASL_PLAINTEXT
    SASL_SSL
}

enum ConnectorState {
    RUNNING
    FAILED
    PAUSED
    UNASSIGNED
    RESTARTING
}

enum StreamsState {
    RUNNING
    REBALANCING
    PENDING_SHUTDOWN
    NOT_RUNNING
    ERROR
}

# FIX: Added UserDto to be used in API responses.
# This prevents leaking sensitive fields like the password hash.
type UserDto {
    id: ID!
    username: String!
    email: String!
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    accessibleEnvironmentIds: [String!]
    isActive: Boolean!
    mfaEnabled: Boolean!
    mfaType: String
}

# MFA Types
type MfaSetupResult {
    secretKey: String!
    qrCodeDataUrl: String!
    qrCodeUri: String!
    deviceId: String!
}

type MfaSetupCompleteResult {
    backupCodes: [String!]!
}

type MfaStatus {
    enabled: Boolean!
    type: String
    unusedBackupCodesCount: Int!
}

# The User type is now used for nested resolutions (e.g., Organization.users)
type User {
    id: ID!
    username: String!
    email: String!
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    organization: Organization
    accessibleEnvironmentIds: [String!]
    accessibleEnvironments: [Environment!]
    isActive: Boolean!
}

type Organization {
    id: ID!
    name: String!
    description: String
    environments: [Environment!]
    clusters: [KafkaCluster!]
    users: [User!]
    isActive: Boolean!
    mfaRequired: Boolean!
    mfaGracePeriodDays: Int
}

type Environment {
    id: ID!
    name: String!
    type: EnvironmentType!
    description: String
    organization: Organization!
    clusters: [KafkaCluster!]
    isActive: Boolean!
}

type KafkaCluster {
    id: ID!
    name: String!
    bootstrapServers: String!
    properties: Map
    isActive: Boolean!
    description: String
    organization: Organization!
    environment: Environment!
    topics: [Topic!]
    consumerGroups: [ConsumerGroup!]
    schemaRegistries: [SchemaRegistry!]
    kafkaConnects: [KafkaConnect!]
    kafkaStreamsApplications: [KafkaStreamsApplication!]
    ksqlDBs: [KsqlDB!]

    # Connection settings
    securityProtocol: SecurityProtocol
    saslMechanism: String
    saslUsername: String
    # Note: Passwords are not returned in queries for security

    # Connection status
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    brokers: [BrokerNode!]
}

type BrokerNode {
    id: Int!
    host: String!
    port: Int!
    rack: String
}

type Topic {
    name: String!
    partitions: Int!
    replicationFactor: Int!
    partitionsInfo: [PartitionInfo!]
    configs: Map
    isInternal: Boolean!
    cluster: KafkaCluster!
}

type TopicPage {
    content: [Topic!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

type PartitionInfo {
    id: Int!
    leader: Int!
    replicas: [Int!]
    isr: [Int!]
    size: Long!
    earliestOffset: Long!
    latestOffset: Long!
}

type ConsumerGroup {
    groupId: String!
    state: String!
    members: [MemberInfo!]
    topicOffsets: Map
    coordinator: String
    cluster: KafkaCluster!
}

type MemberInfo {
    memberId: String!
    clientId: String!
    host: String!
    assignment: [TopicPartition!]
}

type TopicPartition {
    topic: String!
    partition: Int!
}

type SchemaRegistry {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
}

type KafkaConnect {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    connectors: [Connector!]
}

type Connector {
    name: String!
    type: String!
    state: ConnectorState!
    config: String!
    tasks: [Task!]
}

type Task {
    id: Int!
    state: String!
    workerId: String!
    trace: String
}

type KafkaStreamsApplication {
    id: ID!
    name: String!
    applicationId: String!
    cluster: KafkaCluster!
    topics: [String!]
    configuration: Map
    isActive: Boolean!
    state: StreamsState!
    threads: [ThreadMetadata!]
}

type KsqlDB {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    streams: [KsqlStreamTable!]!
    tables: [KsqlStreamTable!]!
}

type KsqlQueryHistory {
    id: ID!
    ksqlDB: KsqlDB!
    user: UserDto!
    queryText: String!
    queryType: String!
    status: String!
    executionTimeMs: Long
    rowsReturned: Int
    errorMessage: String
    startedAt: Long!
    completedAt: Long
    properties: Map
}

type KsqlStreamTable {
    id: ID!
    ksqlDB: KsqlDB!
    name: String!
    type: String!
    topicName: String
    keyFormat: String
    valueFormat: String
    schema: String
    queryText: String
    createdAt: Long!
    updatedAt: Long!
    properties: Map
}

type KsqlQueryResult {
    queryId: String
    columns: [String!]!
    rows: [[String!]!]!
    executionTimeMs: Long
    errorMessage: String
}

type KsqlQueryMetrics {
    queryHistoryId: ID!
    cpuUsagePercent: Float
    memoryUsageMb: Long
    rowsProcessedPerSecond: Long
    bytesRead: Long
    bytesWritten: Long
    timestamp: Long!
}

# Time-series metrics types
type TopicMetrics {
    id: ID!
    clusterId: ID!
    topicName: String!
    messagesPerSecondIn: Long
    bytesPerSecondIn: Long
    totalSizeBytes: Long
    partitionCount: Int!
    partitionSizes: Map
    partitionOffsets: Map
    timestamp: Long!
}

type ConsumerGroupMetrics {
    id: ID!
    clusterId: ID!
    consumerGroupId: String!
    totalLag: Long
    maxLag: Long
    minLag: Long
    avgLag: Long
    totalOffset: Long
    committedOffset: Long
    memberCount: Int!
    activeMemberCount: Int!
    topicLags: Map
    timestamp: Long!
}

type ClusterMetrics {
    id: ID!
    clusterId: ID!
    brokerCount: Int!
    activeBrokerCount: Int!
    totalTopics: Int!
    totalPartitions: Int!
    totalMessagesPerSecond: Long
    totalBytesPerSecond: Long
    isHealthy: Boolean!
    connectionErrorCount: Int!
    brokerDetails: Map
    timestamp: Long!
}

input MetricsTimeRangeInput {
    startTime: Long!
    endTime: Long!
    interval: String  # "1m", "5m", "1h", "1d" for aggregation (optional)
}

type KsqlQueryHistoryPage {
    content: [KsqlQueryHistory!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

enum KsqlQueryType {
    SELECT
    CREATE_STREAM
    CREATE_TABLE
    CREATE_STREAM_AS_SELECT
    CREATE_TABLE_AS_SELECT
    DROP_STREAM
    DROP_TABLE
    TERMINATE
    INSERT
    INSERT_VALUES
    SHOW
    DESCRIBE
    EXPLAIN
    OTHER
}

enum KsqlQueryStatus {
    SUCCESS
    FAILURE
    RUNNING
    CANCELLED
}

enum KsqlStreamTableType {
    STREAM
    TABLE
}

enum SortDirection {
    ASC
    DESC
}

input KsqlQueryInput {
    query: String!
    properties: Map
}

input KsqlQueryFilter {
    queryType: KsqlQueryType
    status: KsqlQueryStatus
    startDate: Long
    endDate: Long
}

input KsqlQueryPagination {
    page: Int!
    size: Int!
    sortBy: String
    sortDirection: SortDirection
}

type ThreadMetadata {
    threadName: String!
    threadState: String!
    consumerClientId: [String!]
    tasks: [TaskMetadata!]
}

type TaskMetadata {
    taskId: Int!
    taskIdString: String!
    topicPartitions: [String!]
    taskState: String!
}

type AuditLog {
    id: ID!
    timestamp: Long!
    userId: String
    userEmail: String
    userRole: String
    actionType: AuditActionType!
    resourceType: AuditResourceType!
    resourceId: String
    resourceName: String
    organizationId: String
    environmentId: String
    clusterId: String
    ipAddress: String
    userAgent: String
    requestId: String
    oldValues: Map
    newValues: Map
    changedFields: [String!]
    status: AuditStatus!
    errorMessage: String
    metadata: Map
    severity: AuditSeverity!
    isSensitive: Boolean!
}

enum AuditActionType {
    CREATE
    UPDATE
    DELETE
    READ
    LOGIN
    LOGOUT
    LOGIN_FAILED
    AUTHORIZATION_DENIED
    AUTHORIZATION_GRANTED
    CONNECTION_TEST
    CONFIGURATION_CHANGE
    BULK_OPERATION
    EXPORT
    IMPORT
    MFA_SETUP_INITIATED
    MFA_SETUP_COMPLETED
    MFA_DISABLED
    MFA_VERIFICATION_SUCCESS
    MFA_VERIFICATION_FAILED
    MFA_BACKUP_CODES_REGENERATED
}

enum AuditResourceType {
    USER
    ORGANIZATION
    ENVIRONMENT
    CLUSTER
    TOPIC
    CONSUMER_GROUP
    SCHEMA_REGISTRY
    KAFKA_CONNECT
    KAFKA_STREAMS
    KSQLDB
    MESSAGE
    MESSAGE_REPLAY
    SCHEMA
    CONNECTOR
    API_KEY
}

enum AuditStatus {
    SUCCESS
    FAILURE
    PARTIAL
}

enum AuditSeverity {
    INFO
    WARNING
    ERROR
    CRITICAL
}

input AuditLogFilter {
    userId: String
    actionType: AuditActionType
    resourceType: AuditResourceType
    resourceId: String
    organizationId: String
    clusterId: String
    status: AuditStatus
    severity: AuditSeverity
    startTime: Long
    endTime: Long
    searchText: String
}

input AuditLogPagination {
    page: Int = 0
    size: Int = 50
    sortBy: String = "timestamp"
    sortDirection: String = "DESC"
}

type AuditLogPage {
    content: [AuditLog!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

type UserPage {
    content: [UserDto!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

type ActionTypeCount {
    actionType: AuditActionType!
    count: Long!
}

type ResourceTypeCount {
    resourceType: AuditResourceType!
    count: Long!
}

type StatusCount {
    status: AuditStatus!
    count: Long!
}

type SeverityCount {
    severity: AuditSeverity!
    count: Long!
}

type RecentActivity {
    timestamp: Long!
    actionType: AuditActionType!
    resourceType: AuditResourceType!
    resourceName: String!
    userEmail: String!
}

type AuditLogStatistics {
    totalCount: Long!
    byActionType: [ActionTypeCount!]!
    byResourceType: [ResourceTypeCount!]!
    byStatus: [StatusCount!]!
    bySeverity: [SeverityCount!]!
    recentActivity: [RecentActivity!]!
}

type AuthResponse {
    token: String!
    user: UserDto
    mfaRequired: Boolean!
    mfaType: String
    mfaGracePeriod: Boolean
    mfaGracePeriodDaysRemaining: Long
    mfaSetupRequired: Boolean
}

input UserInput {
    id: ID
    username: String!
    email: String!
    password: String
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    accessibleEnvironmentIds: [String!]
    isActive: Boolean!
}

input OrganizationInput {
    id: ID
    name: String!
    description: String
    isActive: Boolean!
}

input OrganizationMfaPolicyInput {
    mfaRequired: Boolean!
    mfaGracePeriodDays: Int
}

input EnvironmentInput {
    id: ID
    name: String!
    type: EnvironmentType!
    description: String
    organizationId: String!
    isActive: Boolean!
}

input KafkaClusterInput {
    id: ID
    name: String!
    bootstrapServers: String!
    properties: Map
    isActive: Boolean!
    description: String
    organizationId: String!
    environmentId: String!
    # Connection settings
    securityProtocol: SecurityProtocol
    saslMechanism: String
    saslUsername: String
    saslPassword: String
    sslTruststoreLocation: String
    sslTruststorePassword: String
    sslKeystoreLocation: String
    sslKeystorePassword: String
    sslKeyPassword: String
}

input TopicInput {
    name: String!
    partitions: Int!
    replicationFactor: Int!
    configs: Map
}

input SchemaRegistryInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input KafkaConnectInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input KafkaStreamsApplicationInput {
    id: ID
    name: String!
    applicationId: String!
    clusterId: String!
    topics: [String!]
    configuration: Map
    isActive: Boolean!
}

input KsqlDBInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input LoginInput {
    username: String!
    password: String!
}

input MessageInput {
    topic: String!
    partitions: [Int!]
    offset: String
    limit: Int!
}

# Message Replay Input Types
input MessageReplayInput {
    clusterId: ID!
    sourceTopic: String!
    targetTopic: String
    consumerGroupId: String
    startOffset: Long
    startTimestamp: String
    endOffset: Long
    endTimestamp: String
    partitions: [Int!]
    filters: MessageFilterInput
    transformation: MessageTransformationInput
    scheduleTime: String
    scheduleCron: String
    scheduleTimezone: String
    maxRetries: Int
    retryDelaySeconds: Int
}

input MessageFilterInput {
    keyFilter: KeyFilterInput
    valueFilter: ValueFilterInput
    headerFilters: [HeaderFilterInput!]
    timestampRangeFilter: TimestampRangeFilterInput
    logic: FilterLogic
}

input KeyFilterInput {
    type: KeyFilterType!
    value: String!
}

input ValueFilterInput {
    type: ValueFilterType!
    value: String
    minSize: Long
    maxSize: Long
}

input HeaderFilterInput {
    headerKey: String!
    headerValue: String
    exactMatch: Boolean
}

input TimestampRangeFilterInput {
    startTimestamp: String!
    endTimestamp: String!
}

input MessageTransformationInput {
    keyTransformation: KeyTransformationInput
    valueTransformation: ValueTransformationInput
    headerAdditions: Map
    headerRemovals: [String!]
}

input KeyTransformationInput {
    type: KeyTransformationType!
    newValue: String
}

input ValueTransformationInput {
    type: ValueTransformationType!
    newValue: String
    targetFormat: String
}

enum FilterLogic {
    AND
    OR
}

enum KeyFilterType {
    EXACT
    PREFIX
    REGEX
    CONTAINS
}

enum ValueFilterType {
    JSON_PATH
    REGEX
    CONTAINS
    SIZE
}

enum KeyTransformationType {
    KEEP
    REMOVE
    MODIFY
}

enum ValueTransformationType {
    KEEP
    MODIFY
    FORMAT_CONVERSION
}

type Message {
    partition: Int!
    offset: Long!
    timestamp: Long!
    key: String
    value: String
    headers: Map
}

# Message Replay/Reprocessing Types
enum ReplayJobStatus {
    PENDING
    RUNNING
    COMPLETED
    FAILED
    CANCELLED
}

type ReplayJobProgress {
    messagesProcessed: Long!
    messagesTotal: Long
    throughput: Float
    estimatedTimeRemainingSeconds: Long
    partitionProgress: Map
}

type MessageReplayJob {
    id: ID!
    clusterId: ID!
    sourceTopic: String!
    targetTopic: String
    consumerGroupId: String
    startOffset: Long
    startTimestamp: String
    endOffset: Long
    endTimestamp: String
    partitions: [Int!]
    status: ReplayJobStatus!
    progress: ReplayJobProgress
    scheduleCron: String
    scheduleTimezone: String
    nextScheduledRun: String
    isRecurring: Boolean!
    lastScheduledRun: String
    retryCount: Int!
    maxRetries: Int!
    retryDelaySeconds: Int!
    createdBy: String!
    createdAt: String!
    startedAt: String
    completedAt: String
    errorMessage: String
    metadata: Map
}

type MessageReplayJobHistory {
    id: ID!
    replayJobId: ID!
    action: String!
    messageCount: Long!
    throughput: Float
    timestamp: String!
    details: Map
}

# API Key Management Types
type ApiKey {
    id: ID!
    userId: ID!
    organizationId: ID!
    name: String!
    description: String
    keyPrefix: String!
    scopes: [String!]!
    isActive: Boolean!
    isRevoked: Boolean!
    revokedAt: String
    revokedReason: String
    expiresAt: String
    lastUsedAt: String
    createdAt: String!
    updatedAt: String!
}

type ApiKeyGenerationResult {
    apiKey: ApiKey!
    fullKey: String!  # Only shown once when created
}

type ApiKeyUsageStatistics {
    apiKeyId: ID!
    startTime: String!
    endTime: String!
    totalRequests: Long!
    successCount: Long!
    errorCount: Long!
    errorRate: Float!
    averageResponseTimeMs: Int
    statusCodeCounts: Map
    timeSeriesData: Map
}

type RateLimitConfig {
    id: ID!
    apiKeyId: ID!
    limitType: String!
    limitValue: Int!
    windowSeconds: Int!
    createdAt: String!
    updatedAt: String!
}

input ApiKeyInput {
    name: String!
    description: String
    scopes: [String!]!
    expiresAt: String
}

input ApiKeyUpdateInput {
    name: String
    description: String
    scopes: [String!]
    expiresAt: String
}

input RateLimitConfigInput {
    limitType: String!
    limitValue: Int!
    windowSeconds: Int!
}

type Query {
    # User queries
    me: UserDto
    users(organizationId: String, page: Int, size: Int): UserPage!
    user(id: ID!): UserDto
    mfaStatus: MfaStatus!

    # Organization queries
    organizations: [Organization!]!
    organization(id: ID!): Organization

    # Environment queries
    environments(organizationId: String): [Environment!]!
    environment(id: ID!): Environment

    # Cluster queries
    clusters(organizationId: String, environmentId: String): [KafkaCluster!]!
    cluster(id: ID!): KafkaCluster

    # Topic queries
    topics(clusterId: ID!, page: Int, size: Int, search: String): TopicPage!
    topic(clusterId: ID!, name: String!): Topic

    # Consumer group queries
    consumerGroups(clusterId: ID!): [ConsumerGroup!]!
    consumerGroup(clusterId: ID!, groupId: String!): ConsumerGroup

    # Schema Registry queries
    schemaRegistries(clusterId: ID!): [SchemaRegistry!]!
    schemaRegistry(id: ID!): SchemaRegistry
    schemaRegistrySubjects(schemaRegistryId: ID!): [String!]
    schemaRegistryLatestSchema(schemaRegistryId: ID!, subject: String!): String
    schemaRegistrySchemaVersions(schemaRegistryId: ID!, subject: String!): [Int!]

    # Kafka Connect queries
    kafkaConnects(clusterId: ID!): [KafkaConnect!]!
    kafkaConnect(id: ID!): KafkaConnect

    # Kafka Streams queries
    kafkaStreamsApplications(clusterId: ID!): [KafkaStreamsApplication!]!
    kafkaStreamsApplication(id: ID!): KafkaStreamsApplication

    # ksqlDB queries
    ksqlDBs(clusterId: ID!): [KsqlDB!]!
    ksqlDB(id: ID!): KsqlDB
    ksqlDBServerInfo(ksqlDBId: ID!): String
    
    # ksqlDB Streams/Tables
    ksqlStreams(ksqlDBId: ID!): [KsqlStreamTable!]!
    ksqlTables(ksqlDBId: ID!): [KsqlStreamTable!]!
    ksqlStreamTable(ksqlDBId: ID!, name: String!): KsqlStreamTable
    
    # Metrics queries
    topicMetrics(clusterId: ID!, topicName: String!, timeRange: MetricsTimeRangeInput!, limit: Int = 1000): [TopicMetrics!]!
    consumerGroupMetrics(clusterId: ID!, consumerGroupId: String!, timeRange: MetricsTimeRangeInput!, limit: Int = 1000): [ConsumerGroupMetrics!]!
    clusterMetrics(clusterId: ID!, timeRange: MetricsTimeRangeInput!, limit: Int = 1000): [ClusterMetrics!]!
    
    # ksqlDB Query History
    ksqlQueryHistory(ksqlDBId: ID!, filter: KsqlQueryFilter, pagination: KsqlQueryPagination): KsqlQueryHistoryPage!
    ksqlQueryHistoryById(id: ID!): KsqlQueryHistory
    
    # ksqlDB Metrics
    ksqlQueryMetrics(queryHistoryId: ID!): [KsqlQueryMetrics!]!

    # Message queries
    messages(clusterId: ID!, input: MessageInput!): [Message!]!

    # Audit Log queries
    auditLogs(filter: AuditLogFilter, pagination: AuditLogPagination): AuditLogPage!
    auditLog(id: ID!): AuditLog
    auditLogsByUser(userId: String!, pagination: AuditLogPagination): AuditLogPage!
    auditLogsByResource(resourceType: AuditResourceType!, resourceId: String!, pagination: AuditLogPagination): AuditLogPage!
    auditLogStatistics(filter: AuditLogFilter): AuditLogStatistics!
    
    # API Key queries
    apiKeys: [ApiKey!]!
    apiKey(id: ID!): ApiKey
    apiKeyUsage(id: ID!, startTime: String!, endTime: String!): ApiKeyUsageStatistics!
    apiKeyRateLimits(apiKeyId: ID!): [RateLimitConfig!]!
    
    # Message Replay queries
    replayJobs(clusterId: ID, status: ReplayJobStatus, page: Int = 0, size: Int = 20): [MessageReplayJob!]!
    replayJob(id: ID!): MessageReplayJob
    replayHistory(jobId: ID!, page: Int = 0, size: Int = 20): [MessageReplayJobHistory!]!
}

type Mutation {
    # Authentication mutations
    login(input: LoginInput!): AuthResponse!
    register(input: UserInput!): AuthResponse!
    verifyMfaCode(challengeToken: String!, code: String!, isBackupCode: Boolean = false): AuthResponse!
    
    # MFA management mutations
    setupMfa: MfaSetupResult!
    verifyMfaSetup(deviceId: String!, code: String!): MfaSetupCompleteResult!
    disableMfa(password: String!): Boolean!
    regenerateBackupCodes(password: String!): [String!]!
    
    # Organization MFA policy mutations
    updateOrganizationMfaPolicy(organizationId: ID!, input: OrganizationMfaPolicyInput!): Organization!

    # User mutations
    createUser(input: UserInput!): UserDto!
    updateUser(id: ID!, input: UserInput!): UserDto!
    deleteUser(id: ID!): Boolean!

    # Organization mutations
    createOrganization(input: OrganizationInput!): Organization!
    updateOrganization(id: ID!, input: OrganizationInput!): Organization!
    deleteOrganization(id: ID!): Boolean!

    # Environment mutations
    createEnvironment(input: EnvironmentInput!): Environment!
    updateEnvironment(id: ID!, input: EnvironmentInput!): Environment!
    deleteEnvironment(id: ID!): Boolean!

    # Cluster mutations
    createCluster(input: KafkaClusterInput!): KafkaCluster!
    updateCluster(id: ID!, input: KafkaClusterInput!): KafkaCluster!
    deleteCluster(id: ID!): Boolean!
    testClusterConnection(id: ID!): Boolean!

    # Topic mutations
    createTopic(clusterId: ID!, input: TopicInput!): Topic!
    updateTopic(clusterId: ID!, name: String!, configs: Map!): Topic!
    deleteTopic(clusterId: ID!, name: String!): Boolean!

    # Consumer group mutations
    resetConsumerGroupOffset(clusterId: ID!, groupId: String!, topic: String!, partition: Int!, offset: Long!): Boolean!
    
    # Message Replay mutations
    replayMessages(input: MessageReplayInput!): MessageReplayJob!
    scheduleReplay(input: MessageReplayInput!): MessageReplayJob!
    cancelReplay(id: ID!): Boolean!
    retryReplay(id: ID!): Boolean!
    deleteReplay(id: ID!): Boolean!

    # Schema Registry mutations
    createSchemaRegistry(input: SchemaRegistryInput!): SchemaRegistry!
    updateSchemaRegistry(id: ID!, input: SchemaRegistryInput!): SchemaRegistry!
    deleteSchemaRegistry(id: ID!): Boolean!
    testSchemaRegistryConnection(id: ID!): Boolean!

    # Kafka Connect mutations
    createKafkaConnect(input: KafkaConnectInput!): KafkaConnect!
    updateKafkaConnect(id: ID!, input: KafkaConnectInput!): KafkaConnect!
    deleteKafkaConnect(id: ID!): Boolean!
    testKafkaConnectConnection(id: ID!): Boolean!

    # Kafka Streams mutations
    createKafkaStreamsApplication(input: KafkaStreamsApplicationInput!): KafkaStreamsApplication!
    updateKafkaStreamsApplication(id: ID!, input: KafkaStreamsApplicationInput!): KafkaStreamsApplication!
    deleteKafkaStreamsApplication(id: ID!): Boolean!

    # ksqlDB mutations
    createKsqlDB(input: KsqlDBInput!): KsqlDB!
    updateKsqlDB(id: ID!, input: KsqlDBInput!): KsqlDB!
    deleteKsqlDB(id: ID!): Boolean!
    testKsqlDBConnection(id: ID!): Boolean!
    
    # ksqlDB Query Execution
    executeKsqlQuery(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlQueryResult!
    executeKsqlStatement(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlQueryResult!
    terminateKsqlQuery(ksqlDBId: ID!, queryId: String!): Boolean!
    
    # ksqlDB Stream/Table Management
    createKsqlStream(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlStreamTable!
    createKsqlTable(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlStreamTable!
    dropKsqlStream(ksqlDBId: ID!, streamName: String!): Boolean!
    dropKsqlTable(ksqlDBId: ID!, tableName: String!): Boolean!
    
    # ksqlDB Query History
    deleteKsqlQueryHistory(ksqlDBId: ID!, olderThanDays: Int!): Int!
    
    # API Key mutations
    createApiKey(input: ApiKeyInput!): ApiKeyGenerationResult!
    updateApiKey(id: ID!, input: ApiKeyUpdateInput!): ApiKey!
    revokeApiKey(id: ID!, reason: String): Boolean!
    rotateApiKey(id: ID!, gracePeriodDays: Int): ApiKeyGenerationResult!
    deleteApiKey(id: ID!): Boolean!
    configureApiKeyRateLimits(apiKeyId: ID!, configs: [RateLimitConfigInput!]!): [RateLimitConfig!]!
}