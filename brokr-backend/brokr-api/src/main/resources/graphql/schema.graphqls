scalar Map
scalar Long

enum Role {
    VIEWER
    ADMIN
    SUPER_ADMIN
    SERVER_ADMIN
}

enum EnvironmentType {
    NON_PROD_HOTFIX
    NON_PROD_MINOR
    NON_PROD_MAJOR
    PROD
}

enum SecurityProtocol {
    PLAINTEXT
    SSL
    SASL_PLAINTEXT
    SASL_SSL
}

enum ConnectorState {
    RUNNING
    FAILED
    PAUSED
    UNASSIGNED
    RESTARTING
}

enum StreamsState {
    RUNNING
    REBALANCING
    PENDING_SHUTDOWN
    NOT_RUNNING
    ERROR
}

# FIX: Added UserDto to be used in API responses.
# This prevents leaking sensitive fields like the password hash.
type UserDto {
    id: ID!
    username: String!
    email: String!
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    accessibleEnvironmentIds: [String!]
    isActive: Boolean!
}

# The User type is now used for nested resolutions (e.g., Organization.users)
type User {
    id: ID!
    username: String!
    email: String!
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    organization: Organization
    accessibleEnvironmentIds: [String!]
    accessibleEnvironments: [Environment!]
    isActive: Boolean!
}

type Organization {
    id: ID!
    name: String!
    description: String
    environments: [Environment!]
    clusters: [KafkaCluster!]
    users: [User!]
    isActive: Boolean!
}

type Environment {
    id: ID!
    name: String!
    type: EnvironmentType!
    description: String
    organization: Organization!
    clusters: [KafkaCluster!]
    isActive: Boolean!
}

type KafkaCluster {
    id: ID!
    name: String!
    bootstrapServers: String!
    properties: Map
    isActive: Boolean!
    description: String
    organization: Organization!
    environment: Environment!
    topics: [Topic!]
    consumerGroups: [ConsumerGroup!]
    schemaRegistries: [SchemaRegistry!]
    kafkaConnects: [KafkaConnect!]
    kafkaStreamsApplications: [KafkaStreamsApplication!]
    ksqlDBs: [KsqlDB!]

    # Connection settings
    securityProtocol: SecurityProtocol
    saslMechanism: String
    saslUsername: String
    # Note: Passwords are not returned in queries for security

    # Connection status
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    brokers: [BrokerNode!]
}

type BrokerNode {
    id: Int!
    host: String!
    port: Int!
    rack: String
}

type Topic {
    name: String!
    partitions: Int!
    replicationFactor: Int!
    partitionsInfo: [PartitionInfo!]
    configs: Map
    isInternal: Boolean!
    cluster: KafkaCluster!
}

type PartitionInfo {
    id: Int!
    leader: Int!
    replicas: [Int!]
    isr: [Int!]
    size: Long!
    earliestOffset: Long!
    latestOffset: Long!
}

type ConsumerGroup {
    groupId: String!
    state: String!
    members: [MemberInfo!]
    topicOffsets: Map
    coordinator: String
    cluster: KafkaCluster!
}

type MemberInfo {
    memberId: String!
    clientId: String!
    host: String!
    assignment: [TopicPartition!]
}

type TopicPartition {
    topic: String!
    partition: Int!
}

type SchemaRegistry {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
}

type KafkaConnect {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    connectors: [Connector!]
}

type Connector {
    name: String!
    type: String!
    state: ConnectorState!
    config: String!
    tasks: [Task!]
}

type Task {
    id: Int!
    state: String!
    workerId: String!
    trace: String
}

type KafkaStreamsApplication {
    id: ID!
    name: String!
    applicationId: String!
    cluster: KafkaCluster!
    topics: [String!]
    configuration: Map
    isActive: Boolean!
    state: StreamsState!
    threads: [ThreadMetadata!]
}

type KsqlDB {
    id: ID!
    name: String!
    url: String!
    cluster: KafkaCluster!
    securityProtocol: SecurityProtocol
    username: String
    # Note: Passwords are not returned in queries for security
    isActive: Boolean!
    isReachable: Boolean!
    lastConnectionError: String
    lastConnectionCheck: Long!
    streams: [KsqlStreamTable!]!
    tables: [KsqlStreamTable!]!
}

type KsqlQueryHistory {
    id: ID!
    ksqlDB: KsqlDB!
    user: UserDto!
    queryText: String!
    queryType: String!
    status: String!
    executionTimeMs: Long
    rowsReturned: Int
    errorMessage: String
    startedAt: Long!
    completedAt: Long
    properties: Map
}

type KsqlStreamTable {
    id: ID!
    ksqlDB: KsqlDB!
    name: String!
    type: String!
    topicName: String
    keyFormat: String
    valueFormat: String
    schema: String
    queryText: String
    createdAt: Long!
    updatedAt: Long!
    properties: Map
}

type KsqlQueryResult {
    queryId: String
    columns: [String!]!
    rows: [[String!]!]!
    executionTimeMs: Long
    errorMessage: String
}

type KsqlQueryMetrics {
    queryHistoryId: ID!
    cpuUsagePercent: Float
    memoryUsageMb: Long
    rowsProcessedPerSecond: Long
    bytesRead: Long
    bytesWritten: Long
    timestamp: Long!
}

type KsqlQueryHistoryPage {
    content: [KsqlQueryHistory!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

enum KsqlQueryType {
    SELECT
    CREATE_STREAM
    CREATE_TABLE
    CREATE_STREAM_AS_SELECT
    CREATE_TABLE_AS_SELECT
    DROP_STREAM
    DROP_TABLE
    TERMINATE
    INSERT
    INSERT_VALUES
    SHOW
    DESCRIBE
    EXPLAIN
    OTHER
}

enum KsqlQueryStatus {
    SUCCESS
    FAILURE
    RUNNING
    CANCELLED
}

enum KsqlStreamTableType {
    STREAM
    TABLE
}

enum SortDirection {
    ASC
    DESC
}

input KsqlQueryInput {
    query: String!
    properties: Map
}

input KsqlQueryFilter {
    queryType: KsqlQueryType
    status: KsqlQueryStatus
    startDate: Long
    endDate: Long
}

input KsqlQueryPagination {
    page: Int!
    size: Int!
    sortBy: String
    sortDirection: SortDirection
}

type ThreadMetadata {
    threadName: String!
    threadState: String!
    consumerClientId: [String!]
    tasks: [TaskMetadata!]
}

type TaskMetadata {
    taskId: Int!
    taskIdString: String!
    topicPartitions: [String!]
    taskState: String!
}

type AuditLog {
    id: ID!
    timestamp: Long!
    userId: String
    userEmail: String
    userRole: String
    actionType: AuditActionType!
    resourceType: AuditResourceType!
    resourceId: String
    resourceName: String
    organizationId: String
    environmentId: String
    clusterId: String
    ipAddress: String
    userAgent: String
    requestId: String
    oldValues: Map
    newValues: Map
    changedFields: [String!]
    status: AuditStatus!
    errorMessage: String
    metadata: Map
    severity: AuditSeverity!
    isSensitive: Boolean!
}

enum AuditActionType {
    CREATE
    UPDATE
    DELETE
    READ
    LOGIN
    LOGOUT
    LOGIN_FAILED
    AUTHORIZATION_DENIED
    AUTHORIZATION_GRANTED
    CONNECTION_TEST
    CONFIGURATION_CHANGE
    BULK_OPERATION
    EXPORT
    IMPORT
}

enum AuditResourceType {
    USER
    ORGANIZATION
    ENVIRONMENT
    CLUSTER
    TOPIC
    CONSUMER_GROUP
    SCHEMA_REGISTRY
    KAFKA_CONNECT
    KAFKA_STREAMS
    KSQLDB
    MESSAGE
    SCHEMA
    CONNECTOR
}

enum AuditStatus {
    SUCCESS
    FAILURE
    PARTIAL
}

enum AuditSeverity {
    INFO
    WARNING
    ERROR
    CRITICAL
}

input AuditLogFilter {
    userId: String
    actionType: AuditActionType
    resourceType: AuditResourceType
    resourceId: String
    organizationId: String
    clusterId: String
    status: AuditStatus
    severity: AuditSeverity
    startTime: Long
    endTime: Long
    searchText: String
}

input AuditLogPagination {
    page: Int = 0
    size: Int = 50
    sortBy: String = "timestamp"
    sortDirection: String = "DESC"
}

type AuditLogPage {
    content: [AuditLog!]!
    totalElements: Long!
    totalPages: Int!
    currentPage: Int!
    pageSize: Int!
}

type ActionTypeCount {
    actionType: AuditActionType!
    count: Long!
}

type ResourceTypeCount {
    resourceType: AuditResourceType!
    count: Long!
}

type StatusCount {
    status: AuditStatus!
    count: Long!
}

type SeverityCount {
    severity: AuditSeverity!
    count: Long!
}

type RecentActivity {
    timestamp: Long!
    actionType: AuditActionType!
    resourceType: AuditResourceType!
    resourceName: String!
    userEmail: String!
}

type AuditLogStatistics {
    totalCount: Long!
    byActionType: [ActionTypeCount!]!
    byResourceType: [ResourceTypeCount!]!
    byStatus: [StatusCount!]!
    bySeverity: [SeverityCount!]!
    recentActivity: [RecentActivity!]!
}

type AuthResponse {
    token: String!
    user: UserDto!
}

input UserInput {
    id: ID
    username: String!
    email: String!
    password: String
    firstName: String
    lastName: String
    role: Role!
    organizationId: String
    accessibleEnvironmentIds: [String!]
    isActive: Boolean!
}

input OrganizationInput {
    id: ID
    name: String!
    description: String
    isActive: Boolean!
}

input EnvironmentInput {
    id: ID
    name: String!
    type: EnvironmentType!
    description: String
    organizationId: String!
    isActive: Boolean!
}

input KafkaClusterInput {
    id: ID
    name: String!
    bootstrapServers: String!
    properties: Map
    isActive: Boolean!
    description: String
    organizationId: String!
    environmentId: String!
    # Connection settings
    securityProtocol: SecurityProtocol
    saslMechanism: String
    saslUsername: String
    saslPassword: String
    sslTruststoreLocation: String
    sslTruststorePassword: String
    sslKeystoreLocation: String
    sslKeystorePassword: String
    sslKeyPassword: String
}

input TopicInput {
    name: String!
    partitions: Int!
    replicationFactor: Int!
    configs: Map
}

input SchemaRegistryInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input KafkaConnectInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input KafkaStreamsApplicationInput {
    id: ID
    name: String!
    applicationId: String!
    clusterId: String!
    topics: [String!]
    configuration: Map
    isActive: Boolean!
}

input KsqlDBInput {
    id: ID
    name: String!
    url: String!
    clusterId: String!
    securityProtocol: SecurityProtocol
    username: String
    password: String
    isActive: Boolean!
}

input LoginInput {
    username: String!
    password: String!
}

input MessageInput {
    topic: String!
    partitions: [Int!]
    offset: String
    limit: Int!
}

type Message {
    partition: Int!
    offset: Long!
    timestamp: Long!
    key: String
    value: String
}

type Query {
    # User queries
    me: UserDto
    users(organizationId: String): [UserDto!]!
    user(id: ID!): UserDto

    # Organization queries
    organizations: [Organization!]!
    organization(id: ID!): Organization

    # Environment queries
    environments(organizationId: String): [Environment!]!
    environment(id: ID!): Environment

    # Cluster queries
    clusters(organizationId: String, environmentId: String): [KafkaCluster!]!
    cluster(id: ID!): KafkaCluster

    # Topic queries
    topics(clusterId: ID!): [Topic!]!
    topic(clusterId: ID!, name: String!): Topic

    # Consumer group queries
    consumerGroups(clusterId: ID!): [ConsumerGroup!]!
    consumerGroup(clusterId: ID!, groupId: String!): ConsumerGroup

    # Schema Registry queries
    schemaRegistries(clusterId: ID!): [SchemaRegistry!]!
    schemaRegistry(id: ID!): SchemaRegistry
    schemaRegistrySubjects(schemaRegistryId: ID!): [String!]
    schemaRegistryLatestSchema(schemaRegistryId: ID!, subject: String!): String
    schemaRegistrySchemaVersions(schemaRegistryId: ID!, subject: String!): [Int!]

    # Kafka Connect queries
    kafkaConnects(clusterId: ID!): [KafkaConnect!]!
    kafkaConnect(id: ID!): KafkaConnect

    # Kafka Streams queries
    kafkaStreamsApplications(clusterId: ID!): [KafkaStreamsApplication!]!
    kafkaStreamsApplication(id: ID!): KafkaStreamsApplication

    # ksqlDB queries
    ksqlDBs(clusterId: ID!): [KsqlDB!]!
    ksqlDB(id: ID!): KsqlDB
    ksqlDBServerInfo(ksqlDBId: ID!): String
    
    # ksqlDB Streams/Tables
    ksqlStreams(ksqlDBId: ID!): [KsqlStreamTable!]!
    ksqlTables(ksqlDBId: ID!): [KsqlStreamTable!]!
    ksqlStreamTable(ksqlDBId: ID!, name: String!): KsqlStreamTable
    
    # ksqlDB Query History
    ksqlQueryHistory(ksqlDBId: ID!, filter: KsqlQueryFilter, pagination: KsqlQueryPagination): KsqlQueryHistoryPage!
    ksqlQueryHistoryById(id: ID!): KsqlQueryHistory
    
    # ksqlDB Metrics
    ksqlQueryMetrics(queryHistoryId: ID!): [KsqlQueryMetrics!]!

    # Message queries
    messages(clusterId: ID!, input: MessageInput!): [Message!]!

    # Audit Log queries
    auditLogs(filter: AuditLogFilter, pagination: AuditLogPagination): AuditLogPage!
    auditLog(id: ID!): AuditLog
    auditLogsByUser(userId: String!, pagination: AuditLogPagination): AuditLogPage!
    auditLogsByResource(resourceType: AuditResourceType!, resourceId: String!, pagination: AuditLogPagination): AuditLogPage!
    auditLogStatistics(filter: AuditLogFilter): AuditLogStatistics!
}

type Mutation {
    # Authentication mutations
    login(input: LoginInput!): AuthResponse!
    register(input: UserInput!): AuthResponse!

    # User mutations
    createUser(input: UserInput!): UserDto!
    updateUser(id: ID!, input: UserInput!): UserDto!
    deleteUser(id: ID!): Boolean!

    # Organization mutations
    createOrganization(input: OrganizationInput!): Organization!
    updateOrganization(id: ID!, input: OrganizationInput!): Organization!
    deleteOrganization(id: ID!): Boolean!

    # Environment mutations
    createEnvironment(input: EnvironmentInput!): Environment!
    updateEnvironment(id: ID!, input: EnvironmentInput!): Environment!
    deleteEnvironment(id: ID!): Boolean!

    # Cluster mutations
    createCluster(input: KafkaClusterInput!): KafkaCluster!
    updateCluster(id: ID!, input: KafkaClusterInput!): KafkaCluster!
    deleteCluster(id: ID!): Boolean!
    testClusterConnection(id: ID!): Boolean!

    # Topic mutations
    createTopic(clusterId: ID!, input: TopicInput!): Topic!
    updateTopic(clusterId: ID!, name: String!, configs: Map!): Topic!
    deleteTopic(clusterId: ID!, name: String!): Boolean!

    # Consumer group mutations
    resetConsumerGroupOffset(clusterId: ID!, groupId: String!, topic: String!, partition: Int!, offset: Long!): Boolean!

    # Schema Registry mutations
    createSchemaRegistry(input: SchemaRegistryInput!): SchemaRegistry!
    updateSchemaRegistry(id: ID!, input: SchemaRegistryInput!): SchemaRegistry!
    deleteSchemaRegistry(id: ID!): Boolean!
    testSchemaRegistryConnection(id: ID!): Boolean!

    # Kafka Connect mutations
    createKafkaConnect(input: KafkaConnectInput!): KafkaConnect!
    updateKafkaConnect(id: ID!, input: KafkaConnectInput!): KafkaConnect!
    deleteKafkaConnect(id: ID!): Boolean!
    testKafkaConnectConnection(id: ID!): Boolean!

    # Kafka Streams mutations
    createKafkaStreamsApplication(input: KafkaStreamsApplicationInput!): KafkaStreamsApplication!
    updateKafkaStreamsApplication(id: ID!, input: KafkaStreamsApplicationInput!): KafkaStreamsApplication!
    deleteKafkaStreamsApplication(id: ID!): Boolean!

    # ksqlDB mutations
    createKsqlDB(input: KsqlDBInput!): KsqlDB!
    updateKsqlDB(id: ID!, input: KsqlDBInput!): KsqlDB!
    deleteKsqlDB(id: ID!): Boolean!
    testKsqlDBConnection(id: ID!): Boolean!
    
    # ksqlDB Query Execution
    executeKsqlQuery(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlQueryResult!
    executeKsqlStatement(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlQueryResult!
    terminateKsqlQuery(ksqlDBId: ID!, queryId: String!): Boolean!
    
    # ksqlDB Stream/Table Management
    createKsqlStream(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlStreamTable!
    createKsqlTable(ksqlDBId: ID!, input: KsqlQueryInput!): KsqlStreamTable!
    dropKsqlStream(ksqlDBId: ID!, streamName: String!): Boolean!
    dropKsqlTable(ksqlDBId: ID!, tableName: String!): Boolean!
    
    # ksqlDB Query History
    deleteKsqlQueryHistory(ksqlDBId: ID!, olderThanDays: Int!): Int!
}